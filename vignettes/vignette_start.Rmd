---
title: "Example of use: inferno for penguins"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example of use: inferno for penguins}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
    dev='png',
    fig.asp = 1/sqrt(2),
    fig.width = 8,
    out.width='100%',
    collapse = TRUE,
    comment = "#>"
)
options(knitr.kable.NA = '')
library(inferno)
## Tol colour-blind-friendly palette
palette(c(black='black',
        red='#EE6677',
        blue='#4477AA',
        green='#228833',
        yellow='#CCBB44',
        purple='#AA3377',
        cyan='#66CCEE',
        grey='#BBBBBB',
        midgrey='#888888'))
```

## A crash course in population inference

### Population inferences

A very common type of inference is the following. We have a large or potentially infinite group of entities, each having a set of characteristics. Having checked the characteristics of several entities from this group, we want to make guesses about the characteristics of new entities from the same group.

The description just given is very generic or even vague. Indeed it can be applied to a huge variety of situations.

- The 'entities' could be: objects, like electronic components; or people, or animals, or plants, or events of some kind.
- The characteristics could be: the material the object is made of, and the result of some test made on it; or the age, blood-test results, and disease condition of the person; or the species and body mass of the animal; or the length of the petals of the flower.
- The group could be: electronic components coming out of a particular production line; or people of a given nationality and with given symptoms; or animals from a particular island; or flowers of a specific genus or family.

The possibilities are endless.

Also the kinds of guesses that we want to make can be very diverse. We might want to guess all characteristics of a new entity; or, having checked *some* characteristics of a new entity, we want to guess the ones that we haven't or can't check. Important examples of this kind of inference appear in medicine. For example we may have a group defined as follows:

- *Group*: people from a given nationality, suffering from one of two possible diseases.

And we may consider these characteristics:

- *Characteristics*: age; sex; weight; presence or absence of a particular genetic factor; symptoms from a specific set of possible ones; results from clinical tests taken at different times; kind of disease.

We observed as many as possible of these characteristics in a sample of people from this group. Now a new person from the same group appears in front of us. We check this person's age, sex, weight, symptoms. We need to guess which of the two diseases affects this person.

\
The kind of inference summarily described above has one important aspect. Suppose you have collected a sample from your group of interest, and you want to use this sample to make guesses about new entities from the same group. If someone exchanged one entity in your sample with another one *unsystematically* chosen from the group, then you wouldn't protest. After all, you still have the same number of samples from the same group. This aspect is called **exchangeability**: we say that this kind of inference is exchangeable. There are kinds of inference for which this aspect is not true. For example, suppose you're given some stock data from four consecutive days, and you want to make guesses about the next day. If someone replaced any of your four datapoints with a datapoint an unsystematically chosen other day of the year, then you would protest: the time order of the datapoints matter. This is an example of non-exchangeable inference.

The inferences for which *inferno* is designed are exchangeable ones. We shall also call them **population inferences**.

\
Having discussed these simple examples, let's agree on some more standard terminology. Let's call:

- **Population**: what we've called 'group'.
- **Unit**: what we've called 'entity' -- the object, person, animal, etc.
- **Variate**: what we've called 'characteristic'.

\

### Probability and population frequencies

We have been speaking about "making guesses"; but what does this mean?

When a unit is chosen unsystematically from a population, it's only in rare situations that we may be sure about the characteristics of this unit before checking them. Suppose for instance that the population of interest is 'all adults from a given country'; and the characteristics of interest are *sex*, *weight*, *height*. If a person is chosen from this population, we can't be sure beforehand of how tall this person will be. We can exclude values like 4 m or 20 cm, but we'll be uncertain about many other possible values. Even if someone tells us the sex and weight of this person, we'll still be in doubt, but maybe we can consider some values more probable than others.

That's the keyword: **probability**. Although we are unsure about a characteristic of a unit, we can still find some values more probable than others: we may consider it more probable that the person is 160 cm tall than 180 cm tall; or in a clinical inference we may consider it more probable that the patient has a particular virus than not.

Probability is our *degree of belief* about the value of the unknown characteristic.

Note that probability is not a physical property of the unit. For instance, the person in question may be exactly 158 cm tall; the probability of being 180 cm tall is not something we can "measure" from the person. Also, if we found out some other characteristic of the person -- say we knew the weight, and now we know also the sex -- then the probability we assign to 180 cm may increase or decrease; but the person is exactly the same as before. Probability is not a property of the population either. For instance, for one person from a population we may think 150 cm to be the most probable height, but for another person from the same population we may think 180 cm to be the most probable height instead.

Probability expresses the *information* we have about the characteristic of a unit. This is why another researcher may have a different probability about the same unit: because they may have different information about that unit.

\
There is a situation in which we would all agree about the probability about a characteristic of a unit: when we know the *frequencies* for that characteristic in the population. Suppose for instance that the population of interest is that of penguins who lived in particular locations in some particular years (penguins from other locations or other times are not part of this population). The characteristics are the penguin's *species* and 


[Brakedal & al. (2022)](https://doi.org/10.1016/j.cmet.2022.02.001), which generously and professionally shares its [data](https://www.cell.com/cms/10.1016/j.cmet.2022.02.001/attachment/82e51142-50b8-4f84-a3e0-7c08d641a47b/mmc2.xlsx).

- **Treatment group**: *Binary* variate with values `Placebo` and `NR`.

- **Sex**: *Binary* variate with values `Female` and `Male`.


We store the name of the datafile
```{r}
dataset <- penguins
```
Here are the values for two subjects:
```{r echo = FALSE}
knitr::kable(penguins[1:5,])
```

### "Natural" vs controlled or "biased" variates

## Metadata

Let's load the package:
```{r eval = FALSE}
library(inferno)
```

```{r class.source = 'fold-hide'}
## metadatatemplate(data = datafile, file = 'temp_metadata')
```

```{r}
metadatafile <- 'meta_toydata.csv'
```
The metadata are as follows; `NA` indicate empty fields:
```{r echo = FALSE}
knitr::kable(read.csv(metadatafile, na.strings = ''))
```

*(More to be written here!)*


## Learning

$$
\mathrm{Pr}(Y = y \:\vert\: X = x, \mathrm{data})
$$
As the notation above indicates, *these probabilities also depend on the $\mathrm{data}$ already observed*. They are usually called "posterior probabilities".

We need to prepare the software to perform calculations of posterior probabilities given the observed data. In machine learning an analogous process is called "learning". For this reason the function that achieves this is called `learn()`. It requires at least three arguments:

- `data`, which can be given as a path to the `csv` file containing the data
- `metadata`, which can also be given as a path to the metadata file
- `outputdir`: the name of the directory where the output should be saved.

It may be useful to specify two more arguments:

- `seed`: the seed for the random-number generator, to ensure reproducibility
- `parallel`: the number of CPUs to use for the computation

Alternatively you can set the seed with `set.seed()`, and start a set of parallel workers with the `parallel::makeCluster()` and `doParallel::registerDoParallel()` commands.

The "learning" computation can take tens of minutes, or hours, or even days depending on the number of variates and data in your inference problem. The `learn()` function outputs various messages on how the computation is proceeding. As an example:

```{r eval = FALSE}
learnt <- learn(
    data = datafile,
    metadata = metadatafile,
    outputdir = 'parkinson_computations',
    seed = 16,
    parallel = 12)

#> Registered doParallelSNOW with 12 workers
#>
#> Using 30 datapoints
#> Calculating auxiliary metadata
#>
#> **************************
#> Saving output in directory
#> parkinson_computations
#> **************************
#> Starting Monte Carlo sampling of 3600 samples by 60 chains
#> in a space of 703 (effectively 6657) dimensions.
#> Using 12 cores: 60 samples per chain, 5 chains per core.
#> Core logs are being saved in individual files.
#>
#> C-compiling samplers appropriate to the variates (package Nimble)
#> this can take tens of minutes with many data or variates.
#> Please wait...
```

```{r, include = FALSE}
## learnt <- 'learnt.rds'
```



## Drawing inferences



*(TO BE CONTINUED)*
